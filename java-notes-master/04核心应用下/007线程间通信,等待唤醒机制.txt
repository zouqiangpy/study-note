线程间通信:
  1.多个线程在处理同一个资源,但是处理的动作(线程的任务)却不相同.
  2.为什么要处理线程间对通信:多个线程并发执行时,在默认情况下CPU是随机切换线程的,当我们需要多个线程来共同完成一件任务,并且我们希望他们有规律的执行,那么多线程之间需要一些协调通信,依次来帮我们达到多线程共同操作一份数据.
  3.如何保证线程间通信有效利用资源:多个线程在处理同一个资源,并且任务不同时,需要线程通信来帮助解决线程之间对同一个变量的使用和操作.就是多个线程在操作同一份数据时,避免对同一共享变量的争夺,也就是我们需要通过一定得手段使各个线程能有效的利用资源,这种手段即---等待唤醒机制.




等待唤醒机制:
  很多时候多个线程会有协作机制.就是在一个线程进行了规定操作后,就进入等待状态,等待其他线程执行完他们的代码过后再将其唤醒(notify),在有多个线程进行等待时,如果需要可以使用notifyAll来唤醒所有的等待线程.




等待唤醒方法介绍:
  wait:线程不再活动,不再参与调度,进入wait set中,因此不会浪费CPU资源,也不会去竞争锁了,这时的线程状态即是Waiting.它还是要等着别的线程去执行一个特别的动作,也即是"通知(notify)",在这个对象上等待的线程从wait set中释放出来,重新进入调度队列中(ready queue)中.
  
  notify:选取所通知对象的wait set中的一个线程释放(一般选取等待时间长的线程)

想象:人(线程)陆陆续续的来到一个餐馆(锁对象调用wait)等候就餐,餐馆有座位时,让等候时间最长的人先就餐(同,个锁调用notify).



注意:如果一个类A想用另外一个类B中的变量,可newB类的对象,使其作为A类构造方法的参数传进去
  例:
  public class Product {
    int sum;
    public Product(int sum) {
        this.sum = sum;
    }
  }
  public class Consumer1 extends Thread {    //该类用Product类中的变量sum
    private Product product;
    public Consumer1(Product product) {
        this.product=product;
    }
    product.sum=50;
  }